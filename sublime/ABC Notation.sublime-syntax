%YAML 1.2
---
file_extensions:
  - abc
  - abh
  - abp
first_line_match: ^%abc(?:-\d\.\d)?
scope: source.abc
contexts:
  main:
    # abc tunes
    - match: '^(X:)\s*(\d+)'
      captures:
        1: entity.name.tag.index.abc
        2: variable.parameter.index.abc # meta.toc-list.index.abc
      push: abc-tune

  prototype:
    # comments, directives, namespace comments, remark fields
    - include: comments
    # escape characters
    - include: escape
    # fields
    - include: fields

  abc-tune:
    - meta_scope: meta.tune.abc
    - match: '^(T:)'
      scope: meta.field.title.abc
      captures:
        1: entity.name.tag.title.abc
      push:
        - meta_scope: meta.field.title.abc
        - match: '\s*([^%\n\r]+)'
          captures:
            1: string.unquoted.title.abc # meta.toc-list.title.abc
        - match: $
          pop: true
    # tune-body
    - match: '^(K:)\s*([^\r\n]+)?'
      captures:
        1: entity.name.tag.key.abc
        2: string.unquoted.key.abc
      # TODO: Capture clef variable keywords within key field
      set:
        - include: abc-chord
        - include: abc-note
        - include: abc-rest
        - include: abc-space
        - include: grace
        - include: decoration
        - include: macro
        - include: strings
        - include: operators
        - include: barline
        - include: inline-field
        - match: '^(\s*)?$'
          pop: true
    - match: '^(\s*)?$'
      pop: true

  comments:
    - match: '(?:^\s*)?(?>%(?!%|abc))'
      scope: punctuation.definition.comment.abc
      push:
        - meta_scope: comment.line.percentage.abc
        - match: $
          pop: true
    # directive/pseudo-comment
    - match: '(?>%%)'
      scope: punctuation.definition.comment.abc
      push:
        - meta_scope: meta.directive.abc comment.line.percentage.directive.abc
        - match: '(?i)\b(true|false|yes|no|on|off)\b'
          scope: storage.type.directive.abc
        - match: '\s*(\w*)\b' # '\b' is crucial here!
          captures:
            1: keyword.operator.word.directive.abc
          push:
            - meta_scope: variable.parameter.directive.abc
            - scope: constant.numeric.float.length-unit.abc
              match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
            - match: '(?i)\b(true|false|yes|no|on|off)\b'
              scope: storage.type.directive.abc
            # TODO: include more keywords to be highlighted
            - include: comments
            - match: $
              pop: true
        - match: $
          pop: true
    # namespace comment
    - match: '(?:^\s*)?(?>(%)(abc(?:-\d\.\d)?))'
      scope: comment.line.namespace.abc
      captures:
        1: punctuation.definition.comment.abc
        2: keyword.other.special-method.namespace.abc
    # remark field
    - match: '^(r:)'
      scope: meta.field.remark.abc
      captures:
        1: support.function.field.remark.abc
      push:
        - meta_scope: meta.field.remark.abc
        - match: '[^\n\r]*'
          scope: comment.line.remark.abc
        - match: $
          pop: true
  fields:
    # info fields
    - match: '^([[:alpha:]+&&[^IKPVTXr]]:)'
      scope: meta.field.abc
      captures:
        1: support.function.field.abc
      push:
        - meta_content_scope: meta.field.abc
        - match: '[^\n\r]*'
          scope: string.unquoted.field.abc
        - match: $
          pop: true
    # instruction field
    - match: '^(I:)'
      scope: meta.instruction.abc
      captures:
        1: entity.name.tag.instruction.abc
      push:
        - meta_content_scope: variable.parameter.directive.abc
        - match: '\s*(\w+)\s+'
          captures:
            1: keyword.operator.word.directive.abc
          push:
            - match: '(?i)\b(true|false|yes|no|on|off)\b'
              scope: storage.type.directive.abc
            - match: $
              pop: true
        - match: $
          pop: true
    # voice field
    - match: '^(V:)'
      scope: meta.field.voice.abc
      captures:
        1: entity.name.tag.voice.abc
      push:
        - meta_scope: meta.field.voice.abc
        - match: '\s*([^%\n\r]+)'
          captures:
            1: variable.parameter.voice.abc meta.toc-list.voice.abc
        - match: $
          pop: true
    # part field
    - match: '^(P:)'
      scope: meta.field.part.abc
      captures:
        1: entity.name.tag.part.abc
      push:
        - meta_scope: meta.field.part.abc
        - match: '\s*([^%\n\r]+)'
          captures:
            1: variable.parameter.part.abc meta.toc-list.part.abc
          push:
            - match: $
              pop: true
        - match: $
          pop: true
  abc-note:
    - match: |-
        (?x)
          ([_=\^](?:\d*\/*\d*)|=|[_\^]{2})?
          ([A-Ga-g][,']*)
          (\d*[<>/]*\d*)?
      captures:
        1: constant.language.accidental.abc
        2: constant.character.note.abc
        3: storage.type.note-length.abc # constant.numeric.note-length.abc
  abc-rest:
    - scope: meta.code.abc-rest.abc
      match: '([XZ])(\d+)?'
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc # constant.numeric.rest-length.abc
    - scope: meta.code.abc-rest.abc
      match: |-
        (?x)
          ([xz])
          ((?:\d*\/*(?:\d*)?)|
           (?:\d*>*(?:\d*)?)|
           (?:\d*<*(?:\d*)?))?
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc # constant.numeric.rest-length.abc
  abc-space:
    - scope: meta.code.abc-space.abc
      match: |-
        (?x)
          ([yY])
          (\d+(?:\.\d*(?:pt|in|cm)?)?)?
      captures:
        1: storage.type.spacer.abc
        2: constant.numeric.space-length.abc
  decoration:
    - scope: variable.language.decoration.abc
      match: '(?:^\s*)?([-\.HLMOPSTuv](?!:))'
    - scope: variable.language.decoration.abc
      match: '(!\w+!)'
    - scope: variable.language.decoration.abc
      match: |-
        (?x)
          (\!(?:
              \+|\-\(|\-\)|\/{1,3}|[0-5]|\<\(|\<\)|\<|\>\(|\>\)|\>|\^|
              accent|arpeggio|beam-accel|beam-rall|beambr[12]|beamon|
              breath|coda|courtesy|crescendo|crescendo\(|crescendo\)|
              D\.C\.(?:alcoda|alfine)?|D\.S\.(?:alcoda|alfine)?|
              dacapo|dacoda|diminuendo|diminuendo\(|diminuendo\)|
              dot|downbow|editorial|emphasis|f+|fermata|fine|gmark|
              invertedfermata|invertedturn|invertedturnx|invisible|
              longphrase|lowermordent|marcato|mediumphrase|mf|mordent|
              mp|open|p+|plus|pralltriller|rbend|rbstop|roll|segno|sfz|
              shortphrase|slide|snap|stemless|tenuto|thumb|
              trem[1-4]|trill|trill\(|trill\)|turn|turnx|upbow|uppermordent|wedge|
              xstem|\~\(|\~\))\!)
    # excludes matching '~' from macros in tune
    - scope: variable.language.decoration.abc
      match: (~(?![h-wH-W][a-zA-Z0-9]*))
    - scope: support.type.decoration.slur.abc # storage.modifier.decoration.slur.abc
      match: ((?:\((?![\d:])[',]?)|\))
  barline:
    - scope: meta.barline.abc
      match: ([ \|\]]\])
      captures:
        1: punctuation.separator.barline.abc
    - scope: comment.block.documentation.abc
      match: '(\[\|\]|\[\])'
    - scope: meta.barline.abc
      match: ((?>\[\|:*))
      captures:
        1: punctuation.separator.barline.abc
    - scope: meta.barline.abc
      match: |-
        (?x)
          ((?>
            (?:[\[\|\]][\[\|\]](?=:):)|
            (?:\[+:+)|
            (?::+\[+)|
            (?::+\]*)|
            (?:\]+:+)|
            (?::+\]+)|
            (?:[|]*\]{2}:*)|
            (?:(?=\|)\|[\[\]])|
            (?:[:|]*\|[:|]*)|
            (?:[:|]+\[{1,2})))
          (\d+(?:[,-]\d+)*)?
      captures:
        1: punctuation.separator.barline.abc
        2: punctuation.separator.barline.repeat-length.abc # support.type.barline.abc
    - scope: meta.code.barline.abc
      match: '(:*[\|\[\]])(\d(?:[,-]\d)*)+'
      captures:
        1: punctuation.separator.barline.abc
        2: punctuation.separator.barline.repeat-length.abc # support.type.barline.abc
  macro:
    - match: '(\~[h-zH-Z][a-zA-Z0-9]{,30})'
      scope: support.type.macro.abc
  grace:
    - scope: meta.code.grace.abc
      match: '(\{/?)'
      captures:
        1: support.type.grace.abc
      push:
        - match: ([A-Ga-g][,']*)
          scope: constant.character.note.abc
        - match: (\d*[<>/]*\d*)?
          scope: constant.numeric.note-length.abc # storage.type.note-length.abc
        - include: abc-rest
        - include: decoration
        - match: '(\})'
          captures:
            1: support.type.grace.abc
          pop: true
  operators:
    - match: '(\(\d+(?::\d*(?::\d*)?)?)'
      scope: support.type.tuplet.abc
    - match: '\`'
      scope: support.constant.backquote.abc
    - match: '(\(\&|\&\&?|\&\))'
      scope: support.function.overlay.abc
    - match: '(\$(?= *| *$))'
      scope: support.constant.line-break.abc
    - match: '(\\(?= *| *$))'
      scope: support.constant.line-continue.abc
  abc-chord:
    - match: '(\[(?![:|\[\]\d]|(?:[a-zA-Z]:)))'
      captures:
        1: support.type.decoration.chord.abc # meta.brace.square.chord.abc
      push:
        - meta_scope: meta.chord.abc
        - include: abc-note
        - include: abc-rest
        - include: abc-space
        - include: decoration
        - include: macro
        - include: operators
        - match: '(\](?<![:|]))'
          captures:
            1: support.type.decoration.chord.abc # storage.modifier.decoration.chord.abc
          pop: true
  strings:
    - match: '("(?![_<>^@]))'
      scope: punctuation.definition.string.chord.begin.abc
      push:
        - meta_scope: string.quoted.double.chord.abc
        - meta_include_prototype: false
        - include: escape
        # TODO: Match for symbols in chord strings
        - match: '"'
          scope: punctuation.definition.string.chord.end.abc
          pop: true
    - match: '(\"[_<>^@])'
      scope: punctuation.definition.string.annotation.begin.abc
      push:
        - meta_include_prototype: false
        - meta_content_scope: string.quoted.double.annotation.abc
        - include: escape
        - match: '"'
          scope: punctuation.definition.string.annotation.end.abc
          pop: true
  inline-field:
    - scope: meta.inline-field.abc
      match: (\[[[:alpha:]&&[^IKPVXr]]:)
      captures:
        1: support.function.inline-field.abc
      push:
        - meta_content_scope: string.unquoted.inline-field.abc
        - match: (\])
          captures:
            1: support.function.inline-field.abc
          pop: true
    - scope: meta.inline-field.remark.abc
      match: (\[r:)
      captures:
        1: support.function.inline-field.remark.abc
      push:
        - meta_content_scope: comment.block.remark.abc
        - match: (\])
          captures:
            1: support.function.inline-field.remark.abc
          pop: true
    - scope: meta.inline-field.instruction.abc
      match: (\[I:)\s*(\w+)
      captures:
        1: entity.name.tag.inline-field.instruction.abc
        2: keyword.operator.word.instruction.abc
      push:
        - meta_content_scope: variable.parameter.instruction.abc
        - scope: constant.numeric.float.length-unit.abc
          match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.instruction.abc
          pop: true
    - scope: meta.inline-field.title.abc
      match: (\[T:)
      captures:
        1: entity.name.tag.inline-field.title.abc
      push:
        - meta_content_scope: string.unquoted.title.abc meta.toc-list.title.abc
        - include: escape
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.title.abc
          pop: true
    - scope: meta.inline-field.voice.abc
      match: (\[V:)
      captures:
        1: entity.name.tag.inline-field.voice.abc
      push:
        - meta_content_scope: variable.parameter.voice.abc meta.toc-list.voice.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.voice.abc
          pop: true
    - scope: meta.inline-field.part.abc
      match: (\[P:)
      captures:
        1: entity.name.tag.inline-field.part.abc
      push:
        - meta_content_scope: variable.parameter.part.abc meta.toc-list.part.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.part.abc
          pop: true
  escape:
    - scope: constant.character.escape.abc
      match: (\\.)
    - scope: constant.character.escape.abc
      match: (\\\\)
    - scope: constant.character.escape.abc
      match: (\\u\h{4})
    - scope: constant.character.escape.abc
      match: (?:\\[[:punct:]&&[\w]&&[^[ \t\v\f]]]{2})
    - scope: constant.character.escape.abc
      match: '(?:&\w+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#\d+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#x\h+;)'
    - scope: constant.character.escape.abc
      match: (\\%)

  # accidental:
  #   - match: ([_=\^](?:\d*\/*\d*)|=|[_\^]{2})
  #     scope: constant.language.accidental.abc

  # note:
  #   - match: ([A-Ga-g][,']*)
  #     scope: constant.character.note.abc

  # note-length:
  #   - match: (\d*[<>/]*\d*)?
  #     scope: constant.numeric.note-length.abc # storage.type.note-length.abc

  # abc-note-sequence:
  #   - include: abc-note
  #   - include: grace
  #   - include: decoration
  #   - include: macro
  #   - include: strings

  # abc-rest-sequence:
  #   - include: abc-rest
  #   - include: grace
  #   - include: decoration
  #   - include: macro
  #   - include: strings

  # abc-space-sequence:
  #   - include: abc-space
  #   - include: grace
  #   - include: decoration
  #   - include: macro
  #   - include: strings

  # abc-chord-elements:
  #   - include: abc-note
  #   - include: abc-rest
  #   - include: abc-space
  #   - include: decoration
  #   - include: macro
  #   - include: operators
