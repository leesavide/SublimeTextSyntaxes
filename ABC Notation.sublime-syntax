%YAML 1.2
---
file_extensions:
  - abc
  - abh
  - abp
scope: source.abc
contexts:
  main:
    - match: '^(X:)\s*(\d+)'
      captures:
        1: keyword.control.index.abc
        2: constant.numeric.index.abc # meta.toc-list.index.abc
      push: abc-tune

  prototype:
    - match: '(?:^\s*)?%(?!%|abc)'
      scope: punctuation.definition.comment.abc
      push: line-comment
    - match: '%%'
      scope: punctuation.definition.directive.abc
      push: line-directive
    # Global Fields
    - match: '^([[:alpha:]+&&[^IKPVTXr]]:)'
      scope: punctuation.definition.field.abc
      captures:
        1: entity.other.attribute-name.field.abc
      push: field-value
    - match: '^(I:)'
      scope: punctuation.definition.field.instruction.abc
      captures:
        1: support.constant.instruction.abc
      push: instruction-field
    - match: '^(r:)'
      scope: punctuation.definition.field.remark.abc
      captures:
        1: entity.other.attribute-name.field.remark.abc
      push: remark-field

  field-value:
    - meta_content_scope: meta.field.abc
    - match: '[^\n\r]*'
      scope: string.unquoted.field.abc
    - match: $
      pop: true
  instruction-field:
    - meta_scope: meta.field.instruction.abc
    - match: '\s*(\w+)\s+([^%\n\r]*)'
      captures:
        1: keyword.operator.word.instruction.abc
        2: variable.parameter.instruction.abc
    - include: spacing-length
    - match: $
      pop: true
  remark-field:
    - meta_scope: meta.field.remark.abc
    - match: '[^\n\r]*'
      scope: comment.line.remark.abc
    - match: $
      pop: true
  title-field:
    - meta_scope: meta.field.title.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: string.unquoted.title.abc meta.toc-list.title.abc
    - match: $
      pop: true
  voice-field:
    - meta_scope: meta.field.voice.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: variable.parameter.voice.abc meta.toc-list.voice.abc
    - match: $
      pop: true
  part-field:
    - meta_scope: meta.field.part.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: variable.parameter.part.abc meta.toc-list.part.abc
    - match: $
      pop: true

  instruction-constants:
    - scope: meta.variable.bool.abc
      match: '(true|false)'
      captures:
        1: constant.language.boolean.abc


  spacing-length:
    - scope: meta.variable.space-length.abc
      match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
      captures:
        1: constant.numeric.float.space-length.abc




  abc-tune:
    - meta_scope: meta.tune.abc
    - include: tune-body
    - match: '^(\s*)?$'
      pop: true

  strings:
    # Strings begin and end with quotes, and use backslashes as an escape
    # character
    - match: '("(?![_<>^@]))'
      scope: punctuation.definition.string.chord.begin.abc
      push: chord_string
    - match: '(\"[_<>^@])'
      scope: punctuation.definition.string.annotation.begin.abc
      push: annotation_string
  chord_string:
    - meta_scope: string.quoted.double.chord.abc
    - meta_include_prototype: false
    - include: escape
    # TODO: Match for symbols in chord strings
    - match: '"'
      scope: punctuation.definition.string.chord.end.abc
      pop: true
  annotation_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.annotation.abc
    - include: escape
    - match: '"'
      scope: punctuation.definition.string.annotation.end.abc
      pop: true

  line-comment:
    - meta_scope: comment.line.percentage.abc
    - match: '(?<=abc)abc'
      captures:
        1: comment.line.namespace.abc
        2: constant.numeric.float.namespace.abc
      push: line-namespace
    - match: '(?<=%)%'
      push: line-directive
    - match: $
      pop: true

  line-namespace:
    - meta_scope: meta.namespace.abc
    - match: '(-\d\.\d)?'
      captures:
        1: constant.numeric.float.namespace.abc
    - match: $
      pop: true

  line-directive:
    - meta_scope: comment.line.percentage.directive.abc
    - meta_content_scope: meta.directive.abc
    - match: '\s*(\w*)\b\s*([^\n\r]*)'
      captures:
        1: support.function.directive.abc
        2: variable.parameter.directive.abc
    - match: $
      pop: true

  escape:
    - scope: constant.character.escape.abc
      match: '(\\\\)'
    - scope: constant.character.escape.abc
      match: '(\\u\h{4})'
    - scope: constant.character.escape.abc
      match: '(?:\\[[:punct:]&&[\w]&&[^[ \t\v\f]]]{2})'
    - scope: constant.character.escape.abc
      match: '(?:&\w+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#\d+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#x\h+;)'
    - scope: constant.character.escape.abc
      match: '(\\%)'
