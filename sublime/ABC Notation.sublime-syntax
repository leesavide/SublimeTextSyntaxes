%YAML 1.2
---
file_extensions:
  - abc
  - abh
  - abp
scope: source.abc
contexts:
  main:
    - match: '^(X:)\s*(\d+)'
      captures:
        1: entity.name.tag.index.abc
        2: constant.numeric.index.abc
        # meta.toc-list.index.abc
      push: abc-tune

  prototype:
    # namespace comment
    - match: '(?:^\s*)?%(?!%|abc)'
      scope: punctuation.definition.comment.abc
      push: line-comment
    # directive/pseudo-comment
    - match: '(?>%%)'
      scope: punctuation.definition.comment.abc
      push: line-directive
    # comment (ensure only match for single '%')
    - match: '(?:^\s*)?(?>(%)(abc(?:-\d\.\d)?))'
      scope: comment.line.namespace.abc
      captures:
        1: punctuation.definition.comment.abc
        2: keyword.other.special-method.namespace.abc
    # info fields
    - match: '^([[:alpha:]+&&[^IKPVTXr]]:)'
      scope: meta.field.abc
      captures:
        1: support.function.field.abc
      push: field-value
    # instruction field
    - match: '^(I:)'
      scope: meta.field.instruction.abc
      captures:
        1: entity.name.tag.instruction.abc
      push: instruction-field
    # remark field
    - match: '^(r:)'
      scope: meta.field.remark.abc
      captures:
        1: support.function.field.remark.abc
      push: remark-field
    # voice field
    - match: '^(V:)'
      scope: meta.field.voice.abc
      captures:
        1: entity.name.tag.voice.abc
      push: voice-field
    # part field
    - match: '^(P:)'
      scope: meta.field.part.abc
      captures:
        1: entity.name.tag.part.abc
      push: part-field
    # escapes for literal characters of operator symbols
    - scope: constant.character.escape.abc
      match: (\\.)
    - include: escape

  field-value:
    - meta_content_scope: meta.field.abc
    - match: '[^\n\r]*'
      scope: string.unquoted.field.abc
    - match: $
      pop: true

  instruction-field:
    - meta_scope: meta.instruction.abc
    - meta_content_scope: variable.parameter.instruction.abc
    - match: '\s*(\w+)\s+'
      captures:
        1: keyword.operator.word.instruction.abc
      push:
        - include: directive-constants
        - match: $
          pop: true
    - match: $
      pop: true

  remark-field:
    - meta_scope: meta.field.remark.abc
    - match: '[^\n\r]*'
      scope: comment.line.remark.abc
    - match: $
      pop: true

  title-field:
    - meta_scope: meta.field.title.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: string.unquoted.title.abc # meta.toc-list.title.abc
    - match: $
      pop: true

  voice-field:
    - meta_scope: meta.field.voice.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: storage.modifier.voice.abc meta.toc-list.voice.abc
    - match: $
      pop: true

  part-field:
    - meta_scope: meta.field.part.abc
    - match: '\s*([^%\n\r]+)'
      captures:
        1: storage.modifier.part.abc meta.toc-list.part.abc
      push:
        - match: $
          pop: true
    - match: $
      pop: true

  comments:
    - match: '(?:\s*)?%(?!%|abc)'
      scope: punctuation.definition.comment.abc
      push: line-comment

  directive-value:
    - meta_scope: variable.parameter.directive.abc
    - include: spacing-length
    - include: directive-constants
    # TODO: include more keywords to be highlighted
    - include: comments
    - match: $
      pop: true

  directive-constants:
    - match: '(?i)\b(true|false|yes|no|on|off)\b'
      scope: constant.language.directive.abc

  spacing-length:
    - scope: meta.variable.length-unit.abc
      match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
      captures:
        1: constant.numeric.float.length-unit.abc

  abc-tune:
    - meta_scope: meta.tune.abc
    - match: '^(T:)'
      scope: meta.field.title.abc
      captures:
        1: entity.name.tag.title.abc
      push: title-field
    - include: tune-body
    - match: '^(\s*)?$'
      pop: true

  tune-body:
    - match: '^(K:)\s*([^\r\n]+)?'
      captures:
        1: entity.name.tag.key.abc
        2: string.unquoted.key.abc
      # TODO: Capture clef variable keywords within key field
      push:
        - include: abc-chord
        - include: abc-note-sequence
        - include: abc-rest-sequence
        - include: macro
        - include: operators
        - include: barline
        - include: inline-field
        - include: decoration
        # strangely, this is the 1 match that doesn't get consumed when found.
        # Blank lines are required to set the boundaries of ABC tunes, so this is
        # a good thing.
        - match: '^(\s*)?$'
          pop: true

  abc-note-sequence:
    - include: abc-note
    - include: grace
    - include: decoration
    - include: strings

  abc-rest-sequence:
    - include: abc-rest
    - include: grace
    - include: decoration
    - include: strings

  abc-space-sequence:
    - include: abc-space
    - include: grace
    - include: decoration
    - include: strings

  abc-chord-elements:
    - include: abc-note
    - include: abc-rest
    - include: abc-space
    - include: decoration
    - include: operators

  abc-note:
    - match: |-
        (?x)
          ([_=\^](?:\d*\/*\d*)|=|[_\^]{2})?
          ([A-Ga-g][,']*)
          (\d*[<>/]*\d*)?
      captures:
        1: constant.language.accidental.abc
        2: constant.character.note.abc
        3: constant.numeric.note-length.abc

  abc-rest:
    - scope: meta.code.abc-rest.abc
      match: '([XZ])(\d+)?'
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc
    - scope: meta.code.abc-rest.abc
      match: |-
        (?x)
          ([xz])
          ((?:\d*\/*(?:\d*)?)|
           (?:\d*>*(?:\d*)?)|
           (?:\d*<*(?:\d*)?))?
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc # constant.numeric.rest-length.abc

  abc-space:
    - scope: meta.code.abc-space.abc
      match: |-
        (?x)
          ([yY])
          (\d+(?:\.\d*(?:pt|in|cm)?)?)?
      captures:
        1: storage.type.spacer.abc
        2: constant.numeric.space-length.abc

  accidental:
    - match: ([_=\^](?:\d*\/*\d*)|=|[_\^]{2})
      scope: constant.language.accidental.abc
  note:
    - match: ([A-Ga-g][,']*)
      scope: constant.character.note.abc
  note-length:
    - match: (\d*[<>/]*\d*)?
      scope: constant.numeric.note-length.abc

  decoration:
    - scope: storage.type.decoration.abc
      match: '(?:^\s*)?([-\.~HLMOPSTuv](?!:))'
    - scope: storage.type.decoration.abc
      match: '(!\w+!)'
    - scope: storage.type.decoration.abc
      match: |-
        (?x)
          (\!(?:
              \+|\-\(|\-\)|\/{1,3}|[0-5]|\<\(|\<\)|\<|\>\(|\>\)|\>|\^|
              accent|arpeggio|beam-accel|beam-rall|beambr[12]|beamon|
              breath|coda|courtesy|crescendo|crescendo\(|crescendo\)|
              D\.C\.(?:alcoda|alfine)?|D\.S\.(?:alcoda|alfine)?|
              dacapo|dacoda|diminuendo|diminuendo\(|diminuendo\)|
              dot|downbow|editorial|emphasis|f+|fermata|fine|gmark|
              invertedfermata|invertedturn|invertedturnx|invisible|
              longphrase|lowermordent|marcato|mediumphrase|mf|mordent|
              mp|open|p+|plus|pralltriller|rbend|rbstop|roll|segno|sfz|
              shortphrase|slide|snap|stemless|tenuto|thumb|
              trem[1-4]|trill|trill\(|trill\)|turn|turnx|upbow|uppermordent|wedge|
              xstem|\~\(|\~\))\!)
    - scope: support.type.slur.abc
      match: ((?:\((?![\d:])[',]?)|\))

  barline:
    - scope: meta.barline.abc
      match: ([ \|\]]\])
      captures:
        1: support.type.barline.abc
    - scope: comment.block.documentation.abc
      match: '(\[\|\]|\[\])'
    - scope: meta.barline.abc
      match: ((?>\[\|:*))
      captures:
        1: keyword.operator.barline.abc
    - scope: meta.barline.abc
      match: |-
        (?x)
          ((?>
            (?:[\[\|\]][\[\|\]](?=:):)|
            (?:\[+:+)|
            (?::+\[+)|
            (?::+\]*)|
            (?:\]+:+)|
            (?::+\]+)|
            (?:[|]*\]{2}:*)|
            (?:(?=\|)\|[\[\]])|
            (?:[:|]*\|[:|]*)|
            (?:[:|]+\[{1,2})))
          (\d+(?:[,-]\d+)*)?
      captures:
        1: keyword.operator.barline.abc
        2: support.type.barline.abc
    - scope: meta.code.barline.abc
      match: '(:*[\|\[\]])(\d(?:[,-]\d)*)+'
      captures:
        1: keyword.operator.barline.abc
        2: support.type.barline.abc

  macro:
    - match: '(\~[a-zA-Z][a-zA-Z0-9]{0,30})'
      scope: support.function.macro.abc

  grace:
    - scope: meta.code.grace.abc
      match: '(\{/?)'
      captures:
        1: support.type.grace.abc
      push:
        - include: note
        - include: note-length
        - include: abc-rest
        - include: decoration
        - match: '(\})'
          captures:
            1: support.type.grace.abc
          pop: true

  operators:
    - match: '(\(\d+(?::\d*(?::\d*)?)?)'
      scope: support.type.tuplet.abc
    - match: '\`'
      scope: support.constant.backquote.abc
    - match: '(\(\&|\&\&?|\&\))'
      scope: support.function.overlay.abc
    - match: '(\$(?= *| *$))'
      scope: support.constant.line-break.abc
    - match: '(\\(?= *| *$))'
      scope: support.constant.line-continue.abc

  abc-chord:
    - match: '(\[(?![:|\[\]\d]|(?:[a-zA-Z]:)))'
      captures:
        1: support.type.chord.abc # meta.brace.square.chord.abc
      push:
        - meta_scope: meta.chord.abc
        - include: abc-chord-elements
        - match: '(\](?<![:|]))'
          captures:
            1: support.type.chord.abc # meta.brace.square.chord.abc
          pop: true

  strings:
    - match: '("(?![_<>^@]))'
      scope: punctuation.definition.string.chord.begin.abc
      push: chord_string
    - match: '(\"[_<>^@])'
      scope: punctuation.definition.string.annotation.begin.abc
      push: annotation_string
  chord_string:
    - meta_scope: string.quoted.double.chord.abc
    - meta_include_prototype: false
    - include: escape
    # TODO: Match for symbols in chord strings
    - match: '"'
      scope: punctuation.definition.string.chord.end.abc
      pop: true
  annotation_string:
    - meta_include_prototype: false
    - meta_content_scope: string.quoted.double.annotation.abc
    - include: escape
    - match: '"'
      scope: punctuation.definition.string.annotation.end.abc
      pop: true

  line-comment:
    - meta_scope: comment.line.percentage.abc
    - match: '(?<=abc)abc'
      captures:
        1: comment.line.namespace.abc
        2: constant.numeric.float.namespace.abc
      push: line-namespace
    - match: '(?<=%)%'
      push: line-directive
    - match: $
      pop: true
  line-namespace:
    - meta_scope: meta.namespace.abc
    - match: '(-\d\.\d)?'
      captures:
        1: constant.numeric.float.namespace.abc
    - match: $
      pop: true
  line-directive:
    - meta_scope: meta.directive.abc comment.line.percentage.directive.abc
    - include: directive-constants
    - match: '\s*(\w*)\b' # '\b' is crucial here!
      captures:
        1: support.function.directive.abc
        2: variable.parameter.directive.abc
      push: directive-value
    - match: $
      pop: true

  inline-field:
    - scope: meta.inline-field.abc
      match: (\[[[:alpha:]&&[^IKPVXr]]:)
      captures:
        1: support.function.inline-field.abc
      push:
        - meta_content_scope: string.unquoted.inline-field.abc
        - match: (\])
          captures:
            1: support.function.inline-field.abc
          pop: true
    - scope: meta.inline-field.remark.abc
      match: (\[r:)
      captures:
        1: support.function.inline-field.remark.abc
      push:
        - meta_content_scope: comment.block.remark.abc
        - match: (\])
          captures:
            1: support.function.inline-field.remark.abc
          pop: true
    - scope: meta.inline-field.instruction.abc
      match: (\[I:)\s*(\w+)
      captures:
        1: entity.name.tag.inline-field.instruction.abc
        2: keyword.operator.word.instruction.abc
      push:
        - meta_content_scope: storage.modifier.instruction.abc
        - include: spacing-length
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.instruction.abc
          pop: true
    - scope: meta.inline-field.title.abc
      match: (\[T:)
      captures:
        1: entity.name.tag.inline-field.title.abc
      push:
        - meta_content_scope: string.unquoted.title.abc meta.toc-list.title.abc
        - include: escape
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.title.abc
          pop: true
    - scope: meta.inline-field.voice.abc
      match: (\[V:)
      captures:
        1: entity.name.tag.inline-field.voice.abc
      push:
        - meta_content_scope: storage.modifier.voice.abc meta.toc-list.voice.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.voice.abc
          pop: true
    - scope: meta.inline-field.part.abc
      match: (\[P:)
      captures:
        1: entity.name.tag.inline-field.part.abc
      push:
        - meta_content_scope: storage.modifier.part.abc meta.toc-list.part.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.part.abc
          pop: true

  escape:
    - scope: constant.character.escape.abc
      match: (\\\\)
    - scope: constant.character.escape.abc
      match: (\\u\h{4})
    - scope: constant.character.escape.abc
      match: (?:\\[[:punct:]&&[\w]&&[^[ \t\v\f]]]{2})
    - scope: constant.character.escape.abc
      match: '(?:&\w+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#\d+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#x\h+;)'
    - scope: constant.character.escape.abc
      match: (\\%)
