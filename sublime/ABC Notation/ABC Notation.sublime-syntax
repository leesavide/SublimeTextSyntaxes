%YAML 1.2
---
# http://abcnotation.com/wiki/abc:standard:v2.2
name: ABC Notation
comment: |-
  This was originally based on https://github.com/jimhawkridge/SublimeABC/,
  but later outgrew the limits that PackageDev imposes on tmLanguage files.
file_extensions:
  - abc
  - abh
  - abp
first_line_match: ^%abc(?:-\d\.\d)?
scope: source.abc
variables:
  accidental: '([_=\^](?:\d*\/*\d*)|=|[_\^]{2})'
  note: "([A-Ga-g][,']*)"
  note_length: '(\d*[<>/]*\d*)'
  field_value: '[^%\n\r]'

contexts:
  prototype:
    # escape characters
    - include: escape
    # fields
    - include: fields
    # comments, directives, namespace comments, remark fields
    - include: comments

  comments:
    # line comments
    - match: '(?:^\s*)?(?>%(?!%|abc))'
      scope: comment.line.percentage.abc punctuation.definition.comment.abc
      push:
        - meta_content_scope: comment.line.percentage.abc
        - match: $
          pop: true
    # directives and pseudo-comment
    - match: '((?>%%))\s*(\w*)\b' # '\b' is crucial here!
      scope: meta.directive.abc comment.line.percentage.directive.abc
      captures:
        1: punctuation.definition.comment.abc
        2: keyword.operator.word.directive.abc
      push:
        - meta_content_scope: variable.parameter.directive.abc
        - scope: constant.numeric.float.length-unit.abc
          match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
        - match: '(?i)\b(true|false|yes|no|on|off)\b'
          scope: storage.type.directive.abc
        # TODO: include more keywords to be highlighted
        - match: '\s*(?>%(?!%|abc))'
          scope: comment.line.percentage.abc punctuation.definition.comment.abc
          push:
            - meta_content_scope: comment.line.percentage.abc
            - match: $
              pop: true
        - match: $
          pop: true
    # namespace comment
    - match: '(?:^\s*)?(?>(%)(abc(?:-\d\.\d)?))'
      scope: comment.line.namespace.abc
      captures:
        1: punctuation.definition.comment.abc
        2: keyword.other.special-method.namespace.abc
    # remark field
    - match: '^(r:)'
      scope: meta.field.remark.abc
      captures:
        1: support.function.field.remark.abc
      push:
        - meta_scope: meta.field.remark.abc
        - match: '{{field_value}}*'
          scope: comment.line.remark.abc
        - match: $
          pop: true

  fields:
    # info fields
    - match: '^([[:alpha:]+&&[^IKPVTXr]]:)'
      scope: meta.field.abc
      captures:
        1: support.function.field.abc
      push:
        - meta_content_scope: meta.field.abc
        - include: escape
        - include: comments
        - match: '{{field_value}}*'
          scope: string.unquoted.field.abc
        - match: $
          pop: true
    # instruction field
    - match: '^(I:)'
      scope: meta.instruction.abc
      captures:
        1: entity.name.tag.instruction.abc
      push:
        - meta_content_scope: variable.parameter.directive.abc
        - include: escape
        - include: comments
        - match: '\s*(\w+)\s+'
          captures:
            1: keyword.operator.word.directive.abc
          push:
            - match: '(?i)\b(true|false|yes|no|on|off)\b'
              scope: storage.type.directive.abc
            - match: $
              pop: true
        - match: $
          pop: true
    # voice field
    - match: '^(V:)'
      scope: meta.field.voice.abc
      captures:
        1: entity.name.tag.voice.abc
      push:
        - meta_scope: meta.field.voice.abc
        - include: escape
        - include: comments
        - match: '\s*({{field_value}}+)'
          captures:
            1: variable.parameter.voice.abc # meta.toc-list.voice.abc
        - match: $
          pop: true
    # part field
    - match: '^(P:)'
      captures:
        1: entity.name.tag.part.abc
      push:
        - meta_scope: meta.field.part.abc
        - meta_content_scope: variable.parameter.part.abc # meta.toc-list.part.abc
        - include: escape
        - include: comments
        - match: $
          pop: true

  escape:
    - scope: constant.character.escape.abc
      match: (\\(?:\\|%|[^ \n\r]|u\h{4}|u\h{8}|\\[[:punct:]&&[\w]&&[^[ \t\v\f]]]{2}))
    - scope: constant.character.escape.abc
      match: '(?:&\w+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#\d+;)'
    - scope: constant.character.escape.abc
      match: '(?:&#x\h+;)'

  # Start of ABC Notation
  main:
    # abc tunes
    - match: '^(X:)\s*(\d+)'
      captures:
        1: entity.name.tag.index.abc
        2: variable.parameter.index.abc # meta.toc-list.index.abc
      push: abc-tune

  abc-tune:
    - meta_scope: meta.tune.abc
    - match: '^(T:)'
      scope: meta.field.title.abc
      captures:
        1: entity.name.tag.title.abc
      push:
        - meta_scope: meta.field.title.abc
        - match: '\s*({{field_value}}+)'
          captures:
            1: string.unquoted.title.abc # meta.toc-list.title.abc
        - match: $
          pop: true
    # tune-body
    - match: '^(K:)\s*([^\r\n]+)?'
      captures:
        1: entity.name.tag.key.abc
        2: string.unquoted.key.abc
      # TODO: Capture clef variable keywords within key field
      set:
        - match: '^(K:)\s*([^\r\n]+)?'
          captures:
            1: entity.name.tag.key.abc
            2: string.unquoted.key.abc
        - include: abc-chord
        - include: abc-note
        - include: abc-rest
        - include: abc-space
        - include: grace
        - include: decoration
        - include: macro
        - include: strings
        - include: operators
        - include: barline
        - include: inline-field
        - match: '^(\s*)?$'
          pop: true
    - match: '^(\s*)?$'
      pop: true

  abc-note:
    - match: |-
        (?x)
          {{accidental}}?
          {{note}}
          {{note_length}}?
      captures:
        1: constant.language.accidental.abc
        2: constant.character.note.abc
        3: storage.type.note-length.abc # constant.numeric.note-length.abc

  abc-rest:
    - scope: meta.code.abc-rest.abc
      match: '([XZ])(\d+)?'
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc # constant.numeric.rest-length.abc
    - scope: meta.code.abc-rest.abc
      match: |-
        (?x)
          ([xz])
          ((?:\d*\/*(?:\d*)?)|
           (?:\d*>*(?:\d*)?)|
           (?:\d*<*(?:\d*)?))?
      captures:
        1: storage.type.abc-rest.abc
        2: storage.type.rest-length.abc # constant.numeric.rest-length.abc

  abc-space:
    - scope: meta.code.abc-space.abc
      match: |-
        (?x)
          ([yY])
          (\d+(?:\.\d*(?:pt|in|cm)?)?)?
      captures:
        1: storage.type.spacer.abc
        2: constant.numeric.space-length.abc

  decoration:
    - scope: variable.language.decoration.abc
      match: '(?:^\s*)?([HLMOPSTuv](?!:))'
    - scope: variable.language.decoration.abc
      match: '(!\w+!)'
    - scope: variable.language.decoration.abc
      match: |-
        (?x)
          (\!(?:
              \+|\-\(|\-\)|\/{1,3}|[0-5]|\<\(|\<\)|\<|\>\(|\>\)|\>|\^|
              accent|arpeggio|beam-accel|beam-rall|beambr[12]|beamon|
              breath|coda|courtesy|crescendo|crescendo\(|crescendo\)|
              D\.C\.(?:alcoda|alfine)?|D\.S\.(?:alcoda|alfine)?|
              dacapo|dacoda|diminuendo|diminuendo\(|diminuendo\)|
              dot|downbow|editorial|emphasis|f+|fermata|fine|gmark|
              invertedfermata|invertedturn|invertedturnx|invisible|
              longphrase|lowermordent|marcato|mediumphrase|mf|mordent|
              mp|open|p+|plus|pralltriller|rbend|rbstop|roll|segno|sfz|
              shortphrase|slide|snap|stemless|tenuto|thumb|
              trem[1-4]|trill|trill\(|trill\)|turn|turnx|upbow|uppermordent|wedge|
              xstem|\~\(|\~\))\!)
    # excludes matching '~' from macros in tune
    - scope: variable.language.decoration.abc
      match: (~(?![h-wH-W][a-zA-Z0-9]*))

  barline:
    - scope: meta.barline.abc
      match: ([ \|\]]\])
      captures:
        1: punctuation.separator.barline.abc
    - scope: comment.block.documentation.abc
      match: '(\[\|\]|\[\])'
    - scope: meta.barline.abc
      match: ((?>\[\|:*))
      captures:
        1: punctuation.separator.barline.abc
    - scope: meta.barline.abc
      match: |-
        (?x)
          ((?>
            (?:[\[\|\]][\[\|\]](?=:):)|
            (?:\[+:+)|
            (?::+\[+)|
            (?::+\]*)|
            (?:\]+:+)|
            (?::+\]+)|
            (?:[|]*\]{2}:*)|
            (?:(?=\|)\|[\[\]])|
            (?:[:|]*\|[:|]*)|
            (?:[:|]+\[{1,2})))
          (\d+(?:[,-]\d+)*)?
      captures:
        1: punctuation.separator.barline.abc
        2: punctuation.separator.barline.repeat-length.abc # support.type.barline.abc
    - scope: meta.code.barline.abc
      match: '(:*[\|\[\]])(\d(?:[,-]\d)*)+'
      captures:
        1: punctuation.separator.barline.abc
        2: punctuation.separator.barline.repeat-length.abc # support.type.barline.abc

  macro:
    - match: '(\~[h-zH-Z][a-zA-Z0-9]{,30})'
      scope: support.type.macro.abc

  grace:
    - scope: meta.code.grace.abc
      match: '(\{/?)'
      captures:
        1: support.type.grace.abc
      push:
        - match: ([A-Ga-g][,']*)
          scope: constant.character.note.abc
        - match: (\d*[<>/]*\d*)?
          scope: constant.numeric.note-length.abc # storage.type.note-length.abc
        - include: abc-rest
        - include: decoration
        - match: '(\})'
          captures:
            1: support.type.grace.abc
          pop: true

  operators:
    - match: (\(\&|\&\&?|\&\))
      scope: support.function.overlay.abc
    - match: (\\(?= *| *$))
      scope: support.function.line-continue.abc
    - match: ((?:\((?![\d:])[',]?)|\))
      scope: support.function.slur.abc
    - match: ([-\.`])
      scope: support.type.ties.abc
    - match: (\$(?= *| *$))
      scope: support.type.line-break.abc
    - match: (\(\d+(?::\d*(?::\d*)?)?)
      scope: support.type.tuplet.abc

  abc-chord:
    - match: '(\[(?![:|\[\]\d]|(?:[a-zA-Z]:)))'
      captures:
        1: support.type.decoration.chord.abc # meta.brace.square.chord.abc
      push:
        - meta_scope: meta.chord.abc
        - include: abc-note
        - include: abc-rest
        - include: abc-space
        - include: decoration
        - include: macro
        - include: operators
        - match: '(\](?<![:|]))'
          captures:
            1: support.type.decoration.chord.abc # storage.modifier.decoration.chord.abc
          pop: true

  strings:
    - include: chord-symbol
    - include: annotation

  chord-symbol:
    - match: '("(?![_<>^@]))'
      scope: punctuation.definition.string.chord.begin.abc
      push:
        - meta_scope: string.quoted.double.chord.abc
        - meta_include_prototype: false
        - include: escape
        # TODO: Match for symbols in chord strings
        # (?x)
        #   ([A-G])
        #   ([b#♭♮♯])?
        #   (?>m(in)?|maj|dim|aug|sus|\d|\+)?
        #   (/[A-G])
        - match: '"'
          scope: punctuation.definition.string.chord.end.abc
          pop: true

  annotation:
    - match: '(\"[_<>^@])'
      scope: punctuation.definition.string.annotation.begin.abc
      push:
        - meta_content_scope: string.quoted.double.annotation.abc
        - meta_include_prototype: false
        - include: escape
        - match: '"'
          scope: punctuation.definition.string.annotation.end.abc
          pop: true

  inline-field:
    - scope: meta.inline-field.abc
      match: (\[[[:alpha:]&&[^IKPVXr]]:)
      captures:
        1: support.function.inline-field.abc
      push:
        - meta_content_scope: string.unquoted.inline-field.abc
        - match: (\])
          captures:
            1: support.function.inline-field.abc
          pop: true
    - scope: meta.inline-field.remark.abc
      match: (\[r:)
      captures:
        1: support.function.inline-field.remark.abc
      push:
        - meta_content_scope: comment.block.remark.abc
        - match: (\])
          captures:
            1: support.function.inline-field.remark.abc
          pop: true
    - scope: meta.inline-field.instruction.abc
      match: (\[I:)\s*(\w+)
      captures:
        1: entity.name.tag.inline-field.instruction.abc
        2: keyword.operator.word.instruction.abc
      push:
        - meta_content_scope: variable.parameter.instruction.abc
        - scope: constant.numeric.float.length-unit.abc
          match: '(\d*(?:\.\d*)?(?:pt|in|cm)?)'
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.instruction.abc
          pop: true
    - scope: meta.inline-field.title.abc
      match: (\[T:)
      captures:
        1: entity.name.tag.inline-field.title.abc
      push:
        - meta_content_scope: string.unquoted.title.abc
        - include: escape
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.title.abc
          pop: true
    - scope: meta.inline-field.voice.abc
      match: (\[V:)
      captures:
        1: entity.name.tag.inline-field.voice.abc
      push:
        - meta_content_scope: variable.parameter.voice.abc # meta.toc-list.voice.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.voice.abc
          pop: true
    - scope: meta.inline-field.part.abc
      match: (\[P:)
      captures:
        1: entity.name.tag.inline-field.part.abc
      push:
        - meta_content_scope: variable.parameter.part.abc # meta.toc-list.part.abc
        - match: (\])
          captures:
            1: entity.name.tag.inline-field.part.abc
          pop: true
